#+TITLE: Dropbox TRAMP Backend
#+AUTHOR: Pavel Panchekha <me@pavpanchekha.com>
#+BABEL: :tangle yes
#+DRAWERS: NOTE

The Dropbox TRAMP Backend lets one use Dropbox as an Emacs remote file
system through TRAMP.  This file is a literate program that defines
both the Dropbox shell used by the TRAMP Backend internally and the
small adaptor in Emacs Lisp to let this work.

* Dropbox Shell

The Dropbox Shell is responsible for convincing Emacs that it is a
legitimate remote shell, because this is how TRAMP works.  It should
respond to commands, usually with the minimum possible code, in such
as way as to convince Emacs that it is connected to a Unix box.

:NOTE:
TRAMP is very ugly.  This reflects on the Dropbox Shell used.
:END:

A high-level detail: our method of transferring files is to prey on
the fact that Emacs supports =sudo= not by means of a remote shell but
by just copying files to Emacs' temporary folder.

** Imports

Since Dropbox TRAMP uses the Dropbox API, we have to import that
library.  The latest Developer SDK can be downloaded from the [[http://dropbox.com/developers/releases][Dropbox
Developers Site]]; the version packaged with the source should suffice.

#+BEGIN_SRC python :shebang "#!/usr/bin/env python"
from dropbox import client, session # for API
#+END_SRC

We import =os= for the wonderful =os.path= library, and also =sys= for
access to =stdin= and =stdout=.  We also use regular expressions in a
few places to divine exactly what the hell Emacs is doing.

#+BEGIN_SRC python
import sys # For std{in,out}
import os # For path name operations
import re # For haxxx
#+END_SRC

** API Connection

The first thing the Dropbox Shell does is connect to the API.  This
requires a key and secret (it's an OAuth API).  Shipping the secret
would defeat the point, so go register for one at the [[http://dropbox.com/developers/apps][Dropbox Developer page]].

#+BEGIN_SRC python
KEY = "iybkzcei2msvtfs"
SECRET = "h0i6bjickvpk0nt"
#+END_SRC

Once we have a key and secret, we can connect to the API.

#+BEGIN_SRC python
def connect():
#+END_SRC

To do this, we open a session to the main root (we do not want to be
trapped in a sandbox) and wrap an API client around it.

#+BEGIN_SRC python
    sess = session.DropboxSession(KEY, SECRET, root="dropbox")
    api = client.DropboxClient(sess)
#+END_SRC

We set up the TRAMP backend to pass us the tokens on the command line,
so let's extract that and set the current token --- this effectively
logs us in.

#+BEGIN_SRC python
    sess.set_token(*sys.argv[1:])
#+END_SRC

Finally, we can return the client.  We store one of these in a global,
=API=.

#+BEGIN_SRC python
    return api
API = connect()
#+END_SRC

** Logging

To make it easier to track what's going on, we set up a log file.

This log file will log both sides of the interaction, allowing us to
easily review what went wrong.

For both read and write, we write to the log and flush it, to make
sure we capture all output.

#+BEGIN_SRC python
def read():
    res = sys.stdin.readline()
    log.write(res)
    log.flush()
    return res
#+END_SRC

#+BEGIN_SRC python
def write(line):
    log.write(line)
    log.flush()
    sys.stdout.write(line)
#+END_SRC

*** TODO Remove logging, we're not in dev mode anymore
** Dropbox Operations

We rely heavily on Dropbox API calls for the core filesystem calls.
Here they are abstracted away at the top of the file.

#+BEGIN_SRC python
def list_dir(dir):
    # Returns two lists, of files and of directories
    # or None if fail
    if dir[-2:] == "/.":
        dir = dir[:-2]

    files = []
    dirs = ["."] if dir == "/" else [".", ".."]
    try:
        resp = API.metadata(dir)
    except:
        return None

    if 'contents' not in resp.data: # File
        return None

    for f in resp.data["contents"]:
        fname = os.path.basename(f["path"])
        if f["is_dir"]:
            dirs.append(fname)
        else:
            files.append(fname)

    return files, dirs

def dir_exists(dir):
    try:
        resp = API.metadata(dir)
    except:
        return False

    return "is_dir" in resp.data and resp.data["is_dir"]

def file_exists(file):
    try:
        resp = API.metadata(file)
    except:
        return False

    return "is_dir" in resp.data and not resp.data["is_dir"]

def file_size(file):
    try:
        resp = API.metadata(file)
    except:
        return -1

    if "is_dir" in resp.data and resp.data["is_dir"]:
        return 4096 # I don't think Emacs actually needs this, but my eyes are trained to look for 4096
    elif "bytes" in resp.data:
        return resp.data["bytes"]
    else:
        return -1
#+END_SRC

*** TODO Cache?
** Command System

Since the core interaction model with Emacs is an interactive shell,
we have a dictionary of commands to execute and a decorator for
populating said register.

#+BEGIN_SRC python
COMMANDS = {}
def command(name):
    def decorator(f):
        COMMANDS[name] = f
        return f
    return decorator
#+END_SRC
** Status Codes and Globals

Earlier versions of this code assumed that all commands succeed.  This
turns out not to be sufficient; to capture unsuccessful exits, we
raise an =ErrorStatus= exception.

#+BEGIN_SRC python
class ErrorStatus(Exception): pass
#+END_SRC

If we're going to communicate process status, we have to track it as
well.

#+BEGIN_SRC python
LAST_STATUS = 0
#+END_SRC

Finally, there is one more globals we have to keep track of: the
prompt.  Absurdly enough, Emacs will change the prompt to some
arbitrary hexadecimal string and expect us to use it.  *Sigh*.

#+BEGIN_SRC python
PROMPT = "dbsh $"
#+END_SRC

*** TODO This is horrible, think of a better method.

** Trivial commands

Emacs doesn't actually require a very credible shell --- lots of
commands can just be no-ops.  For example, all of =touch=, =chmod=,
=chown=, =stty=, and similar make no sense in the context of Dropbox.

Note that Emacs does *not* use =cd= for actually moving around
directories.

#+BEGIN_SRC python
for name in ["touch", "chmod", "chown", "stty", "mesg", "biff",
             "set", "unset", "cd", "perl5"]:
    command(name)(lambda *args: None)
#+END_SRC

Similarly, for certain commands we can get away with just outputting a
constant string.  =id= is a good example: we just have it report the
current user at root at all times, a pretty reasonable claim.

#+BEGIN_SRC python
command("pwd",   lambda *args: write("/usr/pavpanchekha\n")
command("which", lambda *args: write("\t1\n")
command("id",    lambda *args: write("0\n")
#+END_SRC

** The =exec= Command

The =exec= command is usually executed exactly once: to start a second
shell with a different prompt.  Unfortunately, we still have to
support it, and further, we have to support the per-process
environment variable syntax, since the shell we start has a different
prompt.

#+BEGIN_SRC python
@command("exec")
def my_exec(*args):
    global PROMPT
#+END_SRC

To extract out the new prompt, we look for arguments that start with
=PS1== (yes, Emacs assumes a Bash-like shell).

#+BEGIN_SRC python
    ps = [arg for arg in args if arg.startswith("PS1=")]
#+END_SRC

Since we're given a prompt that contains a few characters that need
escaping, we have to undo the escaping.

#+BEGIN_SRC python
    if ps: # Emacs demands a certain prompt, usually '#$'
        PROMPT = ps[0][4:].replace("\\", "") # Emacs shell escapes it
#+END_SRC

Honestly, this is remarkably silly, just to make it easier to parse
out the shell from the response.  But what can one do?

** The =test= Command

Emacs uses the =test= command to test whether things are directories
or not.  It's not clear why, since it also uses a Perl script to do
the same, but ignores the Perl output if the =test= output contradicts
it.

#+BEGIN_SRC python
@command("test")
def my_test(*args):
    if len(args) > 1 and  args[0] == "-d":
        dir = args[1]
#+END_SRC

In any case, we can't just query Dropbox for this data, because there
are two distinct types of paths: those that are in Dropbox, and those
that are on the local system that we want to copy files to.
Furthermore, Emacs sometimes tests whether things like =/usr/bin/cp=
are directories before executing them, so we also pretend things in
=/usr/bin= are files.

Our method of disambiguating is to treat all Dropbox and actual
directories as directories, and everything else as a file.

#+BEGIN_SRC python
        if os.path.isdir(dir) or dir_exists(dir): # Dirs stay dirs
            pass
        else: # Everything else is a file
            raise ErrorStatus(1)
#+END_SRC

** The =echo= Command

#+BEGIN_SRC python
@command("echo")
def my_echo(*args):
    def special_cases(arg):
        if ">" in arg[0:2]:
            return None
        elif "\"`getconf" == arg:
            return '"/bin:/usr/bin"'
        elif "PATH`\"" == arg:
            return None
        elif "\"`uname" == arg:
            return '"Dropbox API 1.0"'
        elif "-sr`\"" == arg:
            return None
        elif "\"`tty`\"" == arg:
            return "/dev/ttys1337"
        elif arg == "$?":
            return str(LAST_STATUS)
        elif arg[0] == "~":
            return "/usr/" + arg[1:]
        elif arg == ")":
            return None
        elif arg[:2] == '"`' and arg[-2:] == '`"':
            write('"')
            run_cmd(shlex.split(arg[2:-2]))
            write('"\n')
        else:
            return arg
    write(" ".join(filter(bool, [special_cases(arg) for arg in args])) + "\n")

@command("(")
def my_special(*args):
    #write(repr(args) + "\n")
    if args[2:7] == ("|", "base64", "|", "base64", "-d") and args[0] == "echo":
        write(args[1] + "\n")
    elif args[:2] == ("base64", "</dev/null"):
        return
    elif "-d" in args:
        write("!!!\n")
        return
    else:
        write("!!!\n")
        return
        
@command("cp")
def my_cp(*args):
    args = [arg for arg in args if not arg.startswith("-")] # filter out flags
    src, dst = args[:2]
    try:
        f = API.get_file(src)
        open(dst, "w").write(f.read())
    except:
        f = open(src)
        API.put_file(os.path.dirname(dst), f, name=os.path.basename(dst), overwrite=True)

@command("stat")
def my_stat(*args):
    # Emacs only does this to directories...
    write('("%s" %i)\n' % (args[2], file_size(args[2])))

@command("readlink")
def my_readlink(canon_flag, arg, *args):
    write(arg + "\n")

@command("tramp_vc_registered_read_file_names")
def my_vc(*args):
    write("(\n")
    while True:
        fname = read()[:-1]
        if fname == "EOF":
            break
        write('("%s" "file-exists-p" nil)\n' % fname)
        write('("%s" "file-readable-p" nil)\n' % fname)
    write(")\n")
    read() # Some more shit ignored here
    write("tramp_exit_status 0\n")

@command("ls")
def my_ls(*args):
    global LAST_STATUS
    if len(args) > 1 and args[0] == "-lnd":
        dir = args[1]
        if dir_exists(dir):
            # Print "directory info"
            write("drwxr-xr-x 1 0 0 4096 1992-08-20 17:23 %s\n" % dir)
    elif len(args) > 3 and args[:3] == ("--color=never", "-al", "/dev/null"):
        # Tell Emacs /dev/null exists
        write("crw-rw-rw- 1 pavpanchekha pavpanchekha 1, 3 1992-08-20 17:23 /dev/null\n")
    elif len(args) > 4 and args[:4] == ("--color=never", "--dired", "-al", "/dev/null"):
        # Tell Emacs /dev/null exists
        write("  crw-rw-rw- 1 pavpanchekha pavpanchekha 1, 3 1992-08-20 17:23 /dev/null\n")
        write("//DIRED// 63 72\n")
        write("//DIRED-OPTIONS// --quoting-style=literal\n")
    elif "--dired" in args:
        try:
            files, dirs = list_dir(args[-2]) # -2 is the 2>/dev/null
        except TypeError:
            write("//DIRED-OPTIONS// --quoting-style=literal\n")
            raise ErrorStatus(2)
        lines = []
        for dir in dirs:
            lines.append("  drw------- 1 pavpanchekha pavpanchekha 4096 1992-08-20 17:23 %s\n" % dir)
        for file in files:
            lines.append("  -rw------- 1 pavpanchekha pavpanchekha %i 1992-08-20 17:23 %s\n" % (file_size(file), file))
        write("".join(lines))
        bytes = []
        bytecount = 0
        for line in lines:
            parts = line.strip().split(" ", 7)
            # -1 is newline
            bytes.append(bytecount + len(line) - len(parts[-1]) - 1)
            bytecount += len(line)
            bytes.append(bytecount - 1)
        write("//DIRED// " + " ".join(map(str, bytes)) + "\n")
        write("//DIRED-OPTIONS// --quoting-style literal\n")
    else:
        try:
            files, dirs = list_dir(args[-2]) # -2 is the 2>/dev/null
        except TypeError:
            write("//DIRED-OPTIONS// --quoting-style=literal\n")
            raise ErrorStatus(2)
        lines = []
        for dir in dirs:
            lines.append("drw------- 1 pavpanchekha pavpanchekha 4096 1992-08-20 17:23 %s\n" % dir)
        for file in files:
            lines.append("-rw------- 1 pavpanchekha pavpanchekha %s 1992-08-20 17:23 %s\n" % (file_size(file), file))
        write("".join(lines))

@command("tramp_perl_file_attributes")
def my_file_attributes(file, *args):
    if dir_exists(file):
        write("(t 23 0 0 (19962 30605) (19962 20114) (19962 20114) 4096.0 16877 t (0 . 511) -1)\n")
    elif file_exists(file):
        write("(nil 23 0 0 (19962 30605) (19962 20114) (19962 20114) %i.0 16877 t (0 . 511) -1)\n" % file_size(file))
    else:
        write("nil\n")

@command("tramp_perl_file_truename")
def my_truename(file, *args):
    write('"%s"\n' % file)

@command("tramp_perl_file_name_all_completions")
def my_complete(dir, start, lowercase):
    if lowercase:
        lc = lambda s: s.lower()
    else:
        lc = lambda s: s

    files, dirs = list_dir(dir)

    for file in files:
        if file.startswith(start):
            write(lc(file + "\n"))
    for dir in dirs:
        if dir.startswith(start):
            write(lc(dir + "/" + "\n"))
    write("ok\n")

def run_cmd(args):
    global LAST_STATUS, PROMPT
    try:
        if "/" in args[0]:
            args[0] = args[0].split("/")[-1] # Screw paths
        if ">" in args[0]:
            return # A pipeout, ignore it
    except:
        return

    if looks_like_variable_assignment.match(cmd):
        if cmd[:4] == "PS1=":
            PROMPT = cmd[4:].replace("\\", "")[:-1] # Shell escapes and end of line
        else:
            return # Emacs doesn't actually assign any other important variables
    elif args[0] in COMMANDS:
        try:
            COMMANDS[args[0]](*args[1:])
        except ErrorStatus, e:
            LAST_STATUS = e.args[0]
        else:
            LAST_STATUS = 0
    elif args[0] == "exit":
        sys.exit()
    else:
        write("...\n")

WHILING_AWAY = False
FUNCTIONAL = 0
if __name__ == "__main__":
    import shlex
    looks_like_variable_assignment = re.compile("^[0-9A-Za-z_]+=.*$")
    looks_like_were_looking_for_the_path_of = re.compile("while read d; do if test -x \\$d/(\\w+) -a -f \\$d/\\1; then echo tramp_executable \\$d/\\1; break; fi; done <<'EOF'\n")

    while True:
        write(PROMPT if not WHILING_AWAY and not FUNCTIONAL else "")
        cmd = read()

        if looks_like_were_looking_for_the_path_of.match(cmd): # TRAMP uses this to find program absolute names
            cmd = looks_like_were_looking_for_the_path_of.match(cmd).groups()[0]
            WHILING_AWAY = cmd
            continue # No emacs while loops are useful, trust me
        elif cmd[:3] == "EOF":
            WHILING_AWAY = False
            continue
        elif WHILING_AWAY:
            write("tramp_executable " + cmd[:-1] + "/" + WHILING_AWAY + "\n") # :-1 for newline
            continue
        
        if "{" in cmd:
            FUNCTIONAL += 1
            continue
        elif "}" in cmd:
            FUNCTIONAL -= 1
            if not FUNCTIONAL and ";" in cmd: # Extra command after end of function
                cmd = cmd[cmd.find(";")+1:]
            else:
                continue
        elif FUNCTIONAL:
            continue

        if ";" in cmd:
            cmds = cmd.split(";")
        else:
            cmds = [cmd]
        for cmd in cmds:
            try:
                args = shlex.split(cmd)
            except:
                continue
            
            run_cmd(args)

#+END_SRC

* TRAMP Adaptor

Beyond just having a sweat Dropbox shell, we also need to tell TRAMP
how to connect to this shell.  For convenience, we also wrap 

#+BEGIN_SRC emacs-lisp
  ;; dropbox.el --- an emacs tramp backend for dropbox
  ;; Copyright 2011 Pavel Panchekha <pavpanchekha@gmail.com>
  ;;
  ;; Based on emacs-yammer (https://github.com/psanford/emacs-yammer/blob/master/yammer.el)
  
  
  (add-to-list 'load-path "./oauth/")
  (load "oauth.el")
  (require 'tramp)
  
  (defvar dropbox-consumer-key "iybkzcei2msvtfs")
  (defvar dropbox-consumer-secret "h0i6bjickvpk0nt")
  
  (defvar dropbox-request-url "https://api.dropbox.com/0/oauth/request_token")
  (defvar dropbox-access-url "https://api.dropbox.com/0/oauth/access_token")
  (defvar dropbox-authorization-url "https://www.dropbox.com/0/oauth/authorize")
  (defvar dropbox-access-token nil)
  (defvar dropbox-locale nil)
  
  (defvar dropbox-token-file "~/.dropbox-token")
  
  (defvar dropbox-api-content-host "api.dropbox.com")
  
  (defun dropbox-authenticate ()
    "Get authentication token for dropbox"
    (if (file-exists-p dropbox-token-file)
        (save-excursion
          (find-file dropbox-token-file)
          (let ((str (buffer-substring (point-min) (point-max))))
            (if (string-match "\\([^:]*\\):\\(.*\\)" str)
                (setq dropbox-access-token
                      (make-oauth-access-token
                       :consumer-key dropbox-consumer-key
                       :consumer-secret dropbox-consumer-secret
                       :auth-t (make-oauth-t
                                :token (match-string 1 str)
                                :token-secret (match-string 2 str))))))
          (save-buffer)
          (kill-this-buffer)))
    (unless dropbox-access-token ; Oh, we need to get a token
      (setq dropbox-access-token
            (oauth-authorize-app dropbox-consumer-key dropbox-consumer-secret
                                 dropbox-request-url dropbox-access-url
                                 dropbox-authorization-url))
      (save-excursion
        (find-file dropbox-token-file)
        (end-of-buffer)
        (let ((token (oauth-access-token-auth-t dropbox-access-token)))
          (insert (format "%s:%s\n"
                          (oauth-t-token token)
                          (oauth-t-token-secret token))))
        (save-buffer)
        (kill-this-buffer)))
    dropbox-access-token)
  
  (defun dropbox-connect ()
    (interactive)
  
    (let* ((token (dropbox-authenticate))
           (part (oauth-access-token-auth-t token)))
      (setq dropbox-token (oauth-t-token part))
      (setq dropbox-token-2 (oauth-t-token-secret part)))
  
    (add-to-list 'tramp-methods
           `("db"  (tramp-login-program "python")
                   (tramp-login-args (("/Users/pavel/api/clients/tramp/dbsh.py") (,dropbox-token ,dropbox-token-2)))
                   (tramp-remote-sh "sh"))))
#+END_SRC
